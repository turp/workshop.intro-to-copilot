<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Copilot: Beyond the Basics</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reveal.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/theme/black.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/plugin/highlight/monokai.css">
    <style>
        /* AA Brand Colors */
        :root {
            --r-main-font-size: 32px;   
            --aa-red: #C60C30;
            --aa-blue: #00507F;
            --aa-silver: #C0C0C0;
            --aa-dark: #1a1a1a;
        }

        .reveal {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }

        .reveal h1, .reveal h2, .reveal h3 {
            color: var(--aa-red);
            text-transform: none;
        }

        .reveal h1 {
            font-size: 2.0em;
            margin-bottom: 0.5em;
        }

        .reveal h2 {
            font-size: 1.7em;
            margin-bottom: 0.5em;
        }

        .reveal .subtitle {
            color: var(--aa-silver);
            font-size: 1.2em;
            font-style: italic;
        }

        .reveal section {
            text-align: left;
        }

        .reveal .title-slide {
            text-align: center;
        }

        .reveal .title-slide h1 {
            margin-top: 1em;
        }

        .reveal a {
            color: var(--aa-blue);
        }

        .reveal a:hover {
            color: var(--aa-red);
        }

        .reveal code {
            background: #2d2d2d;
            padding: 2px 8px;
            border-radius: 3px;
        }

        .reveal pre code {
            background: #2d2d2d;
            padding: 20px;
            border-radius: 5px;
            max-height: 500px;
        }

        .reveal .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2em;
            align-items: start;
        }

        .reveal .highlight-box {
            background: var(--aa-blue);
            padding: 1em;
            border-radius: 5px;
            margin: 1em 0;
        }

        .reveal .accent {
            color: var(--aa-red);
            font-weight: bold;
        }

        .reveal ul {
            margin-left: 0;
        }

        .reveal li {
            margin-bottom: 0.5em;
        }

        .reveal .small {
            font-size: 0.8em;
        }

        .reveal .mermaid {
            background: white;
            padding: 20px;
            border-radius: 10px;
            overflow: visible !important;
        }

        .reveal .mermaid svg {
            max-width: 100%;
            height: auto;
            overflow: visible !important;
        }

        .reveal .mermaid .node rect,
        .reveal .mermaid .node circle,
        .reveal .mermaid .node ellipse,
        .reveal .mermaid .node polygon {
            stroke-width: 2px;
        }

        .reveal .mermaid .nodeLabel {
            font-size: 14px !important;
            line-height: 1.4 !important;
            padding: 8px !important;
            white-space: pre-wrap !important;
        }

        .reveal blockquote {
            background: var(--aa-blue);
            border-left: 5px solid var(--aa-red);
            padding: 1em;
            margin: 1em 0;
            font-style: italic;
        }

        .reveal .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1em;
        }

        .reveal .comparison-item {
            padding: 1em;
            border-radius: 5px;
        }

        .reveal .good {
            background: rgba(0, 255, 0, 0.1);
            border-left: 5px solid #00ff00;
        }

        .reveal .bad {
            background: rgba(255, 0, 0, 0.1);
            border-left: 5px solid #ff0000;
        }
    </style>
</head>
<body>
    <div class="reveal">
        <div class="slides">
            
            <!-- Title Slide -->
            <section class="title-slide">
                <h1>GitHub Copilot: Beyond the Basics</h1>
                <p class="subtitle">A Comprehensive Guide for Developers</p>
                <p style="margin-top: 2em;">
                    <small>December 12, 2025</small><br>
                    <small><a href="https://developer.aa.com/access/github-copilot">Get Your License</a></small>
                </p>
                <aside class="notes">
                    Welcome everyone! Today we're diving deep into GitHub Copilot's advanced features.
                    This is beyond simple autocomplete - we'll explore autonomous coding, custom agents, and workflows that will transform how you develop.
                    The presentation is about 60 minutes with time for questions.
                </aside>
            </section>

            <!-- Section 1: IDE Integration -->
            <section>
                <section>
                    <h2>Getting Started: IDE Integration</h2>
                    <p>GitHub Copilot has evolved far beyond simple code completion</p>
                    <aside class="notes">
                        Let's start with the foundation - understanding how Copilot integrates with your development environment.
                        This isn't just about autocomplete anymore. Copilot now offers autonomous agents that can read, analyze, and modify entire codebases.
                    </aside>
                </section>

                <section>
                    <h3>Supported IDEs</h3>
                    <ul>
                        <li><span class="accent">Visual Studio Code</span> - Most feature-rich integration</li>
                        <li><span class="accent">Visual Studio</span> - Optimized for .NET developers</li>
                        <li><span class="accent">IntelliJ IDEA</span> - Java/Kotlin-optimized</li>
                        <li><span class="accent">JetBrains Suite & Neovim</span> - Extended support</li>
                    </ul>
                    <div class="highlight-box">
                        <p><strong>Pro Tip:</strong> VS Code offers the complete Copilot experience with full access to all agents and autonomous coding capabilities.</p>
                    </div>
                    <aside class="notes">
                        VS Code is the recommended IDE for the full Copilot experience.
                        If you're doing .NET work, Visual Studio has deep integration.
                        For Java developers, IntelliJ provides intelligent context awareness.
                        The key is that Copilot works where you work - you don't need to change your tools.
                    </aside>
                </section>

                <section>
                    <h3>Understanding Agent Types</h3>
                    <p>Four distinct agents, each designed for specific workflows</p>
                    <div class="two-column">
                        <div>
                            <h4 style="color: var(--aa-blue);">Asking Agents</h4>
                            <ul>
                                <li><strong>Ask Agent</strong> - Q&A expert</li>
                                <li><strong>Plan Agent</strong> - Strategic planner</li>
                            </ul>
                            <p class="small">Provide information without modifying code</p>
                        </div>
                        <div>
                            <h4 style="color: var(--aa-red);">Editing Agents</h4>
                            <ul>
                                <li><strong>Agent</strong> - Autonomous coder</li>
                                <li><strong>Edit Agent</strong> - Focused editor</li>
                            </ul>
                            <p class="small">Actively read workspace and make changes</p>
                        </div>
                    </div>
                    <aside class="notes">
                        This is a crucial distinction. Asking agents give you information and plans but keep you in control of changes.
                        Editing agents can autonomously read your entire codebase and make modifications across multiple files.
                        Agent mode is the most powerful - it's like having a senior developer who can search, analyze, and refactor your entire project.
                    </aside>
                </section>

                <section>
                    <h3>When to Use Each Agent</h3>
                    <table style="font-size: 0.7em; width: 100%;">
                        <thead>
                            <tr>
                                <th>Agent</th>
                                <th>When to Use</th>
                                <th>Examples</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong style="color: var(--aa-blue);">Ask</strong></td>
                                <td>Need quick answers or explanations</td>
                                <td>Syntax questions, API examples, understanding code</td>
                            </tr>
                            <tr>
                                <td><strong style="color: var(--aa-blue);">Plan</strong></td>
                                <td>Want to see implementation roadmap first</td>
                                <td>Feature planning, refactor scope, architecture changes</td>
                            </tr>
                            <tr>
                                <td><strong style="color: var(--aa-blue);">Edit</strong></td>
                                <td>Making targeted edits to specific files</td>
                                <td>Focused changes, single file edits, quick refactors</td>
                            </tr>
                            <tr>
                                <td><strong style="color: var(--aa-red);">Agent</strong></td>
                                <td>Complex tasks spanning multiple files</td>
                                <td>Multi-file refactoring, debugging, complex features</td>
                            </tr>
                        </tbody>
                    </table>
                    <aside class="notes">
                        Use this table as your decision guide.
                        Ask agent for quick questions - think of it as Stack Overflow integrated into your IDE.
                        Plan agent when you want to understand what will happen before any code changes.
                        Edit agent for focused changes in specific files.
                        Agent mode for complex tasks that require understanding your entire codebase.
                    </aside>
                </section>

                <section>
                    <h3>Model Selection</h3>
                    <ul>
                        <li><span class="accent">Claude Sonnet 4.x</span> (Recommended)
                            <ul class="small">
                                <li>Excels at complex reasoning</li>
                                <li>Best for multi-step problem solving</li>
                            </ul>
                        </li>
                        <li><span class="accent">Claude Haiku 4.x</span> (For Speed)
                            <ul class="small">
                                <li>Faster responses for quick tasks</li>
                            </ul>
                        </li>
                        <li><span class="accent">GPT-4.1</span> (Alternative)
                            <ul class="small">
                                <li>Sometimes better at creative solutions</li>
                            </ul>
                        </li>
                    </ul>
                    <blockquote>
                        Don't settle for the first result. Different models have different strengths - experiment!
                    </blockquote>
                    <aside class="notes">
                        You can switch models anytime using the model picker.
                        Claude Sonnet is recommended for most tasks - it's particularly strong at understanding legacy code and refactoring.
                        Haiku is faster for simple queries.
                        GPT-4.1 might offer more creative approaches to new implementations.
                        The key: if you're not getting good results, try a different model before giving up.
                    </aside>
                </section>
            </section>

            <!-- Section 2: Practical Examples -->
            <section>
                <section>
                    <h2>Hands On: Practical Examples</h2>
                    <p>Before we begin the exercises, let's set up your environment:</p>
                    <ol style="font-size: 0.8em;">
                        <li>Clone one of your existing projects</li>
                        <li>Create a new branch
                            <pre><code class="language-bash" style="font-size: 0.7em;">git checkout -b copilot-workshop</code></pre>
                        </li>
                        <li>Open in your editor
                            <ul class="small">
                                <li>Launch VS Code (or your preferred IDE)</li>
                                <li>Verify Copilot is enabled (bottom right status bar)</li>
                                <li>Open Copilot Chat view (Ctrl+Shift+I / Cmd+Shift+I)</li>
                            </ul>
                        </li>
                    </ol>
                    <aside class="notes">
                        Now let's move from theory to practice. These are real examples you can use today.
                        Each example demonstrates specific Copilot capabilities and includes prompts you can adapt.

                        This is important: students need a safe environment to experiment.
                        Creating a branch means they can try things without fear of breaking their main code.
                        Make sure everyone has Copilot enabled before proceeding.
                        Check the bottom right of VS Code for the Copilot icon - it should show as active.
                        If anyone has issues, help them now before moving forward.
                    </aside>
                </section>

                <section>
                    <h3>Exercise: Generate Professional README Files</h3>
                    <p><strong>The Scenario:</strong> Your project lacks proper documentation</p>
                    <pre><code class="language-plaintext">Create a comprehensive README.md for this project. Include:
- Project overview and purpose
- Installation instructions
- Usage examples with code snippets
- API documentation
- Contributing guidelines
- License information

Analyze the codebase to understand the tech stack.</code></pre>
                    <p class="small"><strong>Key Insight:</strong> Agents analyze your actual code structure to create accurate, tailored documentation</p>
                    <aside class="notes">
                        This is one of the most valuable uses of Copilot - generating documentation that actually matches your implementation.
                        The agent reads your package.json, source files, and project structure.
                        You're not getting generic templates, you're getting documentation specific to YOUR project.
                        Use Agent mode with #codebase context for best results.
                    </aside>
                </section>

                <section>
                    <h3>Exercise: Project Assessment</h3>
                    <pre><code class="language-plaintext">Analyze this codebase and provide:
1. Architecture overview (patterns, structure)
2. Technology stack and dependencies
3. Code quality assessment
4. Security concerns or vulnerabilities
5. Technical debt areas
6. Recommended improvements prioritized by impact</code></pre>
                    <p><strong>What Copilot identifies:</strong></p>
                    <ul class="small">
                        <li>Outdated dependencies with vulnerabilities</li>
                        <li>Code smells and anti-patterns</li>
                        <li>Missing error handling</li>
                        <li>Performance bottlenecks</li>
                    </ul>
                    <aside class="notes">
                        This is like having a code review from a senior architect on demand.
                        The analysis typically takes a few minutes but provides insights that would take hours of manual review.
                        This is incredibly valuable when inheriting legacy code or planning technical debt paydown.
                        The assessment can inform sprint planning and help prioritize improvements.
                    </aside>
                </section>

                <section>
                    <h3>Exercise: Automated Test Generation</h3>
                    <div class="two-column">
                        <div>
                            <h4>Basic Prompt:</h4>
                            <pre><code class="language-plaintext" style="font-size: 0.5em;">Generate unit tests for UserService:
- Happy path scenarios
- Edge cases
- Error handling
- Mock external dependencies
Use Jest</code></pre>
                        </div>
                        <div>
                            <h4>Advanced Prompt:</h4>
                            <pre><code class="language-plaintext" style="font-size: 0.5em;">Create comprehensive test suite:
1. Unit tests (80%+ coverage)
2. Integration tests for APIs
3. Test data factories
4. Mock setup for database
5. Follow AAA pattern</code></pre>
                        </div>
                    </div>
                    <p class="accent">‚ö†Ô∏è Important: Always review tests to ensure they make sense</p>
                    <aside class="notes">
                        Test generation is one of the best ROI activities with Copilot.
                        Writing tests is tedious but critical. Copilot excels at generating test scaffolding and common test cases.
                        The agent understands common patterns but doesn't know your unique business requirements.
                        Always review generated tests, but you'll save hours of boilerplate writing.
                    </aside>
                </section>

                <section>
                    <h3>Exercise: Meta-Prompting</h3>
                    <p>Let Copilot write better prompts for you</p>
                    <pre><code class="language-plaintext">
Create a prompt that I can use to create unit tests for my project. 
Goal is 80%+ coverage. 
Follow AAA pattern. 
Use the builder pattern to create test data.
                    </code></pre>
                    <p>Copilot knows what it needs to generate better code</p>
                    <aside class="notes">
                        This is an advanced technique that experienced users leverage heavily.
                        Copilot knows its own capabilities and limitations better than we do.
                        By asking it to write prompts, you learn what information leads to better results.
                        This helps establish team standards and creates reusable prompt templates.
                    </aside>
                </section>

                <section>
                    <h3>Example 5: Debugging with Context</h3>
                    <pre><code class="language-plaintext" style="font-size: 0.5em;">Analyze this error and suggest fixes:

Error: Cannot read property 'user' of undefined
    at UserController.getProfile (src/controllers/user.js:45)

Context:
- Express API endpoint: GET /api/users/:id/profile
- Uses JWT authentication middleware
- MongoDB database
- Error occurs intermittently (5% of requests)

Provide:
1. Root cause analysis
2. Specific code fix
3. How to prevent similar issues
4. Logging/monitoring improvements</code></pre>
                    <aside class="notes">
                        Debugging is where context really matters. The more information you provide, the better the analysis.
                        Include the full error message, stack trace, what the code is trying to do, when it fails, and any recent changes.
                        Copilot can identify race conditions, missing null checks, auth issues, and async/await problems.
                    </aside>
                </section>

                <section>
                    <h3>Example 6: API Migration</h3>
                    <div class="comparison">
                        <div class="comparison-item bad">
                            <h4>‚ùå Before (Express 4, JS)</h4>
                            <pre><code class="language-javascript" style="font-size: 0.4em;">const express = require('express');
router.get('/users/:id', async (req, res) => {
  try {
    const user = await User.findById(req.params.id);
    res.json(user);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});</code></pre>
                        </div>
                        <div class="comparison-item good">
                            <h4>‚úÖ After (Express 5, TS)</h4>
                            <pre><code class="language-typescript" style="font-size: 0.4em;">import { Router, Request, Response } from 'express';

router.get('/users/:id',
  param('id').isMongoId(),
  async (req: Request, res: Response): Promise&lt;void&gt; => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ errors: errors.array() });
      return;
    }
    const user = await User.findById(req.params.id);
    if (!user) {
      res.status(404).json({ error: 'User not found' });
      return;
    }
    res.json(user);
  }
);</code></pre>
                        </div>
                    </div>
                    <aside class="notes">
                        Migrations are tedious and error-prone. Copilot excels at these systematic transformations.
                        It can handle framework upgrades, REST to GraphQL conversions, ORM changes.
                        The key is providing clear requirements and examples of the patterns you want.
                        Always test thoroughly, but Copilot saves countless hours on boilerplate conversion.
                    </aside>
                </section>

            </section>

            <!-- Section 3: Building Reusable Assets -->
            <section>
                <section>
                    <h2>Building Reusable Assets</h2>
                    <p>Don't start from scratch every time</p>
                    <aside class="notes">
                        The most efficient Copilot users build libraries of prompts, instructions, and custom agents.
                        These assets encode your team's best practices and common workflows.
                        Think of them as guardrails that keep Copilot aligned with your standards.
                    </aside>
                </section>

                <section>
                    <h3>Custom Assets Architecture</h3>
                    <pre><code class="language-plaintext">your-project/
‚îú‚îÄ‚îÄ .github/
‚îÇ     ‚îú‚îÄ‚îÄ prompts/
‚îÇ     ‚îÇ   ‚îú‚îÄ‚îÄ create-readme.prompt
‚îÇ     ‚îÇ   ‚îú‚îÄ‚îÄ generate-tests.prompt
‚îÇ     ‚îÇ   ‚îî‚îÄ‚îÄ code-review.prompt
‚îÇ     ‚îú‚îÄ‚îÄ instructions/
‚îÇ     ‚îÇ   ‚îú‚îÄ‚îÄ testing.instructions.md
‚îÇ     ‚îÇ   ‚îú‚îÄ‚îÄ api-design.instructions.md
‚îÇ     ‚îÇ   ‚îî‚îÄ‚îÄ security.instructions.md
‚îÇ     ‚îî‚îÄ‚îÄ agents/
‚îÇ         ‚îú‚îÄ‚îÄ docs-agent.md
‚îÇ         ‚îú‚îÄ‚îÄ test-agent.md
‚îÇ         ‚îî‚îÄ‚îÄ security-agent.md
‚îî‚îÄ‚îÄ README.md</code></pre>
                    <aside class="notes">
                        This is the recommended file structure for custom assets.
                        Store them in .github/ so they're version-controlled with your code.
                        Prompts are reusable templates for common tasks.
                        Instructions guide Copilot's behavior for specific domains.
                        Agents are specialized AI assistants with defined roles.
                    </aside>
                </section>

                <section>
                    <h3>Prompts (.prompt files)</h3>
                    <p>Pre-written templates you can invoke quickly</p>
                    <pre><code class="language-markdown">
---
agent: 'agent'
description: 'Create a README.md file for the project'
---

Create a professional README.md following this structure:
- Badge section (build status, coverage, version)
- Project description with clear value proposition
- Quick start (&lt; 5 minutes to first result)
- Detailed installation
- Usage examples with code blocks
- API reference
- Contributing guidelines
- License

Tailor content based on detected language and framework.</code></pre>
                    <p class="small">Save in <code>.github/prompts/create-readme.prompt.md</code></p>
                    <aside class="notes">
                        Prompts eliminate the need to retype common instructions.
                        They ensure consistency across your team.
                        Anyone can invoke these prompts and get standardized output.
                        Build a library for your most frequent tasks: API endpoints, tests, config files, CI/CD pipelines.
                    </aside>
                </section>


                <section>
                    <h3>Exercise: Create a Reusable Prompt</h3>
                    <p>Build prompt templates your team can share</p>
                    <p>Create .github/prompts/create-unit-tests.prompt.md</p>
                    <p>Ask Copilot:</p>
                    <pre><code class="language-markdown">
Create a reusable prompt to generate unit tests for this project. 
If a file name is not provided, ask for it.
</code></pre>

                    <p>Then test it:</p>
                    <pre><code class="language-plaintext">
/create-unit-tests UserService.cs
</code></pre>
                    <aside class="notes">
                        Reusable prompts eliminate the need to retype common instructions.
                        They ensure consistency across your team - anyone can invoke these prompts and get standardized output.
                        Build a library for your most frequent tasks: API endpoints, tests, config files, CI/CD pipelines.
                        Store them in .github/prompts/ so they're version-controlled with your code.
                    </aside>
                </section>

                <section>
                    <h3>Instructions (.instructions.md files)</h3>
                    <p>Style guides that Copilot automatically follows</p>
                    <pre><code class="language-yaml" style="font-size: 1em;">---
description: 'API Design Standards'
applyTo: '**/*.java'
---
When creating REST APIs:
- Use plural nouns for resource names (/users, not /user)
- Implement proper HTTP status codes
- Include pagination for list endpoints (page, limit, total)
- Use snake_case for JSON keys
- Always validate input with detailed error messages
- Add OpenAPI/Swagger documentation
- Implement rate limiting headers</code></pre>
                    <p><strong>When to create:</strong> Team-specific standards, security practices, architectural patterns</p>
                    <p class="small">Save in <code>.github/instructions/api-design.instructions.md</code></p>

                    <aside class="notes">
                        Instructions are like living style guides that Copilot follows automatically.
                        Instead of catching violations in code review, the code is generated correctly from the start.
                        They're especially valuable for specialized frameworks, security practices, and naming conventions.
                        New team members inherit these standards immediately through Copilot.
                    </aside>
                </section>

                <section>
                    <h3>Exercise: Create Custom Instructions</h3>
                    <p>Define coding standards that Copilot automatically follows</p>
                    <p>Create  .github/instructions/code-standards.instructions.md</p>
                    <pre><code class="language-markdown">
Create comprehensive code standards for this project. Include:
- File and directory structure conventions
- Naming conventions (variables, functions, classes, files)
- Code formatting and style guidelines
- Error handling standards
- Testing requirements
- Common anti-patterns to avoid

Use clear, actionable language with code examples.
</code></pre>
                    <p class="small">Instructions are like living style guides - code is generated correctly from the start</p>
                    <aside class="notes">
                        Instructions are powerful because they act automatically on matching files.
                        Instead of catching violations in code review, the code is generated correctly from the start.
                        They're especially valuable for specialized frameworks, security practices, and naming conventions.
                        New team members inherit these standards immediately through Copilot.
                        Review checklist: Are rules specific and actionable? Do code examples use correct syntax? Aligns with official style guides?
                    </aside>
                </section>

                <section>
                    <h3>Custom Agents (.agent.md files)</h3>
                    <p>Specialized AI assistants for specific workflows</p>
                    <div class="two-column">
                        <div>
                            <h4>What Makes a Great Agent:</h4>
                            <ul class="small">
                                <li>Clear role and expertise</li>
                                <li>Specific commands it can use</li>
                                <li>Code examples of preferred style</li>
                                <li>Defined boundaries</li>
                            </ul>
                        </div>
                        <div>
                            <h4>Agent Ideas:</h4>
                            <ul class="small">
                                <li>@docs-agent - Documentation writer</li>
                                <li>@test-agent - QA engineer</li>
                                <li>@lint-agent - Style fixer</li>
                            </ul>
                        </div>
                    </div>
                    <aside class="notes">
                        Custom agents build upon the four built-in agents.
                        They're specialized assistants with narrow, focused expertise.
                        A test agent only writes tests. A docs agent only writes documentation.
                        This focus produces better results than a general-purpose agent.
                        Start with one agent for your most common task and iterate.
                    </aside>
                </section>

                <section>
                    <h3>Agent File Structure</h3>
                    <pre><code class="language-markdown">---
name: test-agent
description: QA engineer who writes comprehensive tests
---

You are a quality software engineer who writes comprehensive tests.

## Commands
- Run tests: `npm test`
- Coverage: `npm run test:coverage`

## Code style
‚úÖ Good - descriptive names, proper mocking
‚ùå Bad - vague names, no assertions

## Boundaries
- ‚úÖ Always do: Write to `tests/` directory, include edge cases
- ‚ö†Ô∏è Ask first: Before modifying test configuration
- üö´ Never do: Remove failing tests, modify source code</code></pre>
                    <aside class="notes">
                        This shows the structure of an effective agent file.
                        Clear role, specific commands, code examples, and boundaries.
                        The three-tier boundary system is key: always do, ask first, never do.
                        Pro tip: Use Copilot itself to generate agent files - it knows what makes a good agent!
                    </aside>
                </section>

                <section>
                    <h3>Exercise: Create a Custom Agent</h3>
                    <p>Create .github/agents/coding-expert.agent.md</p>
                    <p>Ask Copilot to help you create an agent:</p>
                    <pre><code class="language-markdown">
Create a [python/java/c#] expert agent file. The agent should:
- Write code following project code standards
- Use type hints and docstrings
- Write tests
- Follow TDD and SOLID principles
- Include specific commands to run tests and linters
    </code></pre>
                    <div class="two-column">
                        <div>
                            <p class="small"><strong>Great Agent Traits:</strong></p>
                            <ul class="small">
                                <li>Clear, focused role</li>
                                <li>Specific commands</li>
                                <li>Code examples</li>
                                <li>Defined boundaries</li>
                            </ul>
                        </div>
                        <div>
                            <p class="small"><strong>Boundaries:</strong></p>
                            <ul class="small">
                                <li>‚úÖ Always do</li>
                                <li>‚ö†Ô∏è Ask first</li>
                                <li>üö´ Never do</li>
                            </ul>
                        </div>
                    </div>
                    <aside class="notes">
                        Custom agents are specialized assistants with narrow, focused expertise.
                        A test agent only writes tests. A docs agent only writes documentation.
                        This focus produces better results than a general-purpose agent.
                        Start with one agent for your most common task and iterate based on team feedback.
                        Pro tip: Use Copilot itself to generate agent files - it knows what makes a good agent!
                        The three-tier boundary system is key: always do, ask first, never do.
                    </aside>
                </section>
            </section>

            <!-- Section 4: Best Practices & Tips -->
            <section>
                <section>
                    <h2>Best Practices & Tips</h2>
                    <p>Effective patterns for AI-assisted development</p>
                    <aside class="notes">
                        Now let's talk about best practices that separate good Copilot users from great ones.
                        These aren't just tips - they're battle-tested workflows from experienced developers.
                    </aside>
                </section>

                <section>
                    <h3>5 AI-Assisted Coding Techniques</h3>
                    <ol>
                        <li><span class="accent">Let AI Read Your Design Docs First</span>
                            <p class="small">Provide complete context before asking for code</p>
                        </li>
                        <li><span class="accent">Use One AI to Code, Another to Review</span>
                            <p class="small">Generate code, then review it in a fresh session</p>
                        </li>
                        <li><span class="accent">Automate Tests and Validation</span>
                            <p class="small">Let AI generate and maintain test suites</p>
                        </li>
                        <li><span class="accent">AI-Driven Refactoring</span>
                            <p class="small">Modernize legacy code safely and incrementally</p>
                        </li>
                        <li><span class="accent">Work Asynchronously</span>
                            <p class="small">Use multiple chat sessions for parallel tasks</p>
                        </li>
                    </ol>
                    <aside class="notes">
                        These five techniques are the foundation of efficient AI-assisted development.
                        #1 - Don't give isolated prompts. Share design docs and architecture first.
                        #2 - Fresh perspective catches issues the generator missed.
                        #3 - Testing is tedious but critical. Perfect for delegation to AI.
                        #4 - Legacy code modernization without the pain.
                        #5 - Don't wait for responses. Queue up distinct tasks in parallel.
                    </aside>
                </section>

                <section>
                    <h3>Choosing the Right Interaction</h3>
                    <table style="font-size: 0.6em;">
                        <thead>
                            <tr>
                                <th>Task Type</th>
                                <th>Method</th>
                                <th>Why</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Quick syntax question</td>
                                <td>Ask agent</td>
                                <td>Fast, focused answer</td>
                            </tr>
                            <tr>
                                <td>Refactoring multiple files</td>
                                <td>Agent mode</td>
                                <td>Autonomous, reads workspace</td>
                            </tr>
                            <tr>
                                <td>Planning complex feature</td>
                                <td>Plan agent</td>
                                <td>Roadmap before changes</td>
                            </tr>
                            <tr>
                                <td>Focused edit in current file</td>
                                <td>Inline chat (Ctrl+I)</td>
                                <td>Keeps you in flow</td>
                            </tr>
                            <tr>
                                <td>Code while actively typing</td>
                                <td>Inline suggestions</td>
                                <td>Autocomplete on steroids</td>
                            </tr>
                        </tbody>
                    </table>
                    <aside class="notes">
                        Choosing the right interaction method is critical for efficiency.
                        Inline suggestions for active coding - that's your autocomplete.
                        Ask agent for quick questions - like Stack Overflow in your IDE.
                        Agent mode for complex multi-file work - that's your autonomous coder.
                        Plan agent when you want to see what will happen first.
                        Inline chat for quick edits without context switching.
                    </aside>
                </section>

                <section>
                    <h3>Security Considerations</h3>
                    <div class="two-column">
                        <div>
                            <h4 style="color: #ff4444;">‚ùå Never Share:</h4>
                            <ul class="small">
                                <li>API keys or secrets</li>
                                <li>Passwords</li>
                                <li>Connection strings with credentials</li>
                                <li>PII (personally identifiable info)</li>
                                <li>Proprietary business logic</li>
                            </ul>
                        </div>
                        <div>
                            <h4 style="color: #44ff44;">‚úÖ Always Review:</h4>
                            <ul class="small">
                                <li>Authentication/authorization logic</li>
                                <li>Input validation</li>
                                <li>Cryptographic operations</li>
                                <li>Database queries</li>
                                <li>File system operations</li>
                            </ul>
                        </div>
                    </div>
                    <blockquote>
                        Treat Copilot's output like code from a junior developer - it might be excellent, but always needs review.
                    </blockquote>
                    <aside class="notes">
                        Security is non-negotiable. Never include sensitive data in prompts.
                        Your prompts may be used to improve the model, so treat them as potentially public.
                        For security-critical code, use a multi-step approach: generate, review, verify, test, peer review.
                        Copilot is a tool that amplifies your expertise, not a replacement for security judgment.
                    </aside>
                </section>

                <section>
                    <h3>Performance Tips</h3>
                    <div class="two-column">
                        <div>
                            <h4>Faster Iteration:</h4>
                            <ul class="small">
                                <li>Keep prompts concise but complete</li>
                                <li>Build a prompt library</li>
                                <li>Use keyboard shortcuts</li>
                                <li>Use inline chat for quick edits</li>
                            </ul>
                        </div>
                        <div>
                            <h4>Better Results:</h4>
                            <ul class="small">
                                <li>Reference files explicitly</li>
                                <li>Specify frameworks and versions</li>
                                <li>Include error messages when debugging</li>
                                <li>Mention performance requirements upfront</li>
                            </ul>
                        </div>
                    </div>
                    <div class="highlight-box">
                        <p><strong>Context Management:</strong> Use #codebase, #file, #selection to add specific context. Choose the right agent mode for your task.</p>
                    </div>
                    <aside class="notes">
                        These tips come from thousands of hours of Copilot usage.
                        Concise prompts with complete context produce the best results.
                        Build a library so you don't retype common instructions.
                        Learn keyboard shortcuts to stay in flow.
                        Explicit references help Copilot understand exactly what you want to modify.
                    </aside>
                </section>

                <section>
                    <h3>Common Pitfalls to Avoid</h3>
                    <ul>
                        <li><span class="accent">Over-reliance</span> - Don't stop thinking critically</li>
                        <li><span class="accent">Ignoring edge cases</span> - AI generates happy-path code</li>
                        <li><span class="accent">Skipping tests</span> - Fast code generation ‚â† skip testing</li>
                        <li><span class="accent">Copy-paste without understanding</span> - Always understand the code</li>
                        <li><span class="accent">Not updating instructions</span> - Keep custom assets current</li>
                        <li><span class="accent">Exposing sensitive data</span> - Never include secrets in prompts</li>
                    </ul>
                    <aside class="notes">
                        These are the most common mistakes new Copilot users make.
                        Copilot amplifies your expertise but isn't a replacement for engineering judgment.
                        Always think about edge cases, error conditions, and boundary scenarios.
                        Fast code generation makes testing even more important, not less.
                        Always understand code before integrating it.
                        Keep your custom assets updated as your standards evolve.
                    </aside>
                </section>

                <section>
                    <h3>Continuous Feedback-Driven Workflow</h3>
                    <table style="font-size: 0.75em; width: 100%;">
                        <thead>
                            <tr>
                                <th>Step</th>
                                <th>Action</th>
                                <th>Purpose</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr style="background: rgba(0, 80, 127, 0.2);">
                                <td>1</td>
                                <td><strong>Design Docs</strong></td>
                                <td>Provide complete context before coding</td>
                            </tr>
                            <tr style="background: rgba(198, 12, 48, 0.2);">
                                <td>2</td>
                                <td><strong>Generate Code</strong></td>
                                <td>AI creates initial implementation</td>
                            </tr>
                            <tr style="background: rgba(0, 80, 127, 0.2);">
                                <td>3</td>
                                <td><strong>Review</strong></td>
                                <td>Fresh perspective catches issues</td>
                            </tr>
                            <tr style="background: rgba(198, 12, 48, 0.2);">
                                <td>4</td>
                                <td><strong>Test</strong></td>
                                <td>Generate or update test suites</td>
                            </tr>
                            <tr style="background: rgba(0, 80, 127, 0.2);">
                                <td>5</td>
                                <td><strong>Refactor</strong></td>
                                <td>Modernize and improve code</td>
                            </tr>
                            <tr style="background: rgba(198, 12, 48, 0.2);">
                                <td>6</td>
                                <td><strong>Iterate</strong></td>
                                <td>Improve prompts, repeat cycle ‚Üª</td>
                            </tr>
                        </tbody>
                    </table>
                    <p class="small">Chain techniques into a continuous workflow for maximum efficiency</p>
                    <aside class="notes">
                        This is how experienced users work. It's not about using one technique - it's about chaining them.
                        Start with design-driven prompting for clear context.
                        Generate code, then review from a fresh perspective.
                        Automate test generation to ensure everything stays verifiable.
                        Use AI for refactoring and modernization in the background.
                        Feed back results to refine your prompts over time.
                        This creates a virtuous cycle where your AI workflows mature into reliable systems.
                    </aside>
                </section>
            </section>

            <!-- Section 5: Final Exercise -->
            <section>
                <section>
                    <h3>Final Exercise: Security Vulnerability Automation</h3>
                    <p><strong>Objective:</strong> Utilize <span class="accent">meta-prompting</span> and <span class="accent">custom agents</span> to automate a common task</p>
                    
                    <h4>The Scenario:</h4>
                    <p class="small">Periodically, someone on your team checks <code>Nuclei</code> for security vulnerabilities. Let's use Copilot to automate this repetitive task and free you up for other interesting things.</p>
                    
                    <h4>Your Task:</h4>
                    <p class="small">Ask Copilot to:</p>
                    <ul class="small">
                        <li>Create a GitHub action to periodically check <code>Nuclei</code> for new vulnerabilities</li>
                        <li>Create an issue for each vulnerability found</li>
                        <li>Assign each issue to your <code>GitHub Copilot Agent</code> for it to work on</li>
                    </ul>
                </section>


                <section>
                    <h3>Final Exercise: Security Vulnerability Automation</h3>
                    <div>
                        <h4>The Workflow:</h4>
                        <p class="small">The agent creates a branch and PR, you guide it via comments in the PR, review, and merge when satisfied.</p>
                        
                        <h4>Execute this prompt:</h4>
                        <pre><code class="language-markdown">create a prompt that will create a GitHub action 
that will check nucleus for Critical/High 
vulnerabilities on a daily basis and will create 
GitHub issues for each vulnerabilities and assign 
it to an agent to resolve.</code></pre>
                    </div>
                </section>
                <section>
                    <h3>Final Exercise: Security Vulnerability Automation</h3>                   
                    <div style="margin-top: 1em;">
                        <h4>What to Expect:</h4>
                        <div class="comparison">
                            <div class="comparison-item" style="background: rgba(0, 128, 255, 0.1); border-left: 5px solid #0080ff;">
                                <p class="small"><strong>Gemini:</strong> Focuses on official Nuclei Action, GitHub CLI</p>
                            </div>
                            <div class="comparison-item" style="background: rgba(128, 0, 255, 0.1); border-left: 5px solid #8000ff;">
                                <p class="small"><strong>Claude:</strong> Emphasizes comprehensive lifecycle management, adaptable approach</p>
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 1em;">
                        <p class="small"><strong>Learning Objectives:</strong> Practice meta-prompting ‚Ä¢ Break down complex automation ‚Ä¢ Evaluate different AI approaches ‚Ä¢ Create reusable security automation</p>
                        <p class="small"><strong>Next Steps:</strong> Try with different models ‚Üí Use generated prompt to create the actual GitHub Action ‚Üí Review for security best practices ‚Üí Adapt pattern for other tools (Snyk, Trivy, Dependabot)</p>
                    </div>
                    
                    <aside class="notes">
                        This final exercise brings together meta-prompting and custom agents for real-world automation.
                        The power here is that you're not just generating code - you're creating a self-sustaining security workflow.
                        Different models provide different approaches - Gemini focuses on using official actions while Claude emphasizes comprehensive lifecycle management.
                        The agent can autonomously create branches and PRs, you guide it via PR comments, review when ready, and merge.
                        This pattern can be adapted for other security tools: Snyk, Trivy, Dependabot, or any repetitive security task.
                        Real-world value: Automates repetitive security scanning so your team can focus on remediation strategy and high-impact security work.
                        This is the future of development - AI handling the repetitive tasks while humans focus on creative problem-solving.
                    </aside>
                </section>

            </section>


            <!-- Closing Slide -->
            <section>
                <section class="title-slide">
                    <h2>Key Takeaways</h2>
                    <ul style="text-align: left; display: inline-block;">
                        <li>Start small - Begin with documentation and tests</li>
                        <li>Be specific - Detailed prompts produce better results</li>
                        <li>Build assets - Create reusable prompts and instructions</li>
                        <li>Stay secure - Always review code, never expose secrets</li>
                        <li>Choose the right agent for the task</li>
                        <li>Iterate and refine your approach continuously</li>
                    </ul>
                    <aside class="notes">
                        Let's recap the key points.
                        Start small with low-risk, high-value tasks like documentation.
                        Be specific in your prompts - context is everything.
                        Build custom assets to encode your team's standards.
                        Security is non-negotiable - review everything, never share secrets.
                        Choose the right interaction method for each task.
                        This is an iterative process - you'll get better with practice.
                    </aside>
                </section>

                <section class="title-slide">
                    <h2>Remember</h2>
                    <blockquote style="font-size: 1.2em;">
                        Copilot is a tool that amplifies your expertise. The better developer you are, the more value you'll extract from it.
                    </blockquote>
                    <p style="margin-top: 2em;">Use it to eliminate repetitive work so you can focus on creative, high-impact aspects of software engineering.</p>
                    <aside class="notes">
                        This is the most important point: Copilot amplifies expertise, it doesn't replace it.
                        The better you are at software engineering, the more effective you'll be with Copilot.
                        Use it for what computers do well - repetitive tasks, boilerplate, pattern recognition.
                        Save your brain power for what humans do well - creativity, architecture, business logic.
                    </aside>
                </section>

                <section class="title-slide">
                    <h1>Thank You!</h1>
                    <p style="margin-top: 2em;">
                        <strong>Get Your License:</strong><br>
                        <a href="https://developer.aa.com/access/github-copilot">developer.aa.com/access/github-copilot</a>
                    </p>
                    <p style="margin-top: 2em;">
                        <strong>Resources:</strong><br>
                        <a href="https://docs.github.com/copilot">GitHub Copilot Docs</a><br>
                        <a href="https://github.com/github/awesome-copilot">Awesome Copilot Repository</a>
                    </p>
                    <p style="margin-top: 2em; font-size: 0.8em;">Questions?</p>
                    <aside class="notes">
                        Thank you for your time today! I hope you found this valuable.
                        Get your license at the link shown if you haven't already.
                        Check out the Awesome Copilot repository for more prompts and examples.
                        I'm happy to take questions now or connect afterward.
                    </aside>
                </section>
            </section>

        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reveal.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/plugin/notes/notes.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/plugin/highlight/highlight.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/plugin/markdown/markdown.js"></script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            flowchart: {
                htmlLabels: true,
                curve: 'basis',
                padding: 15
            },
            themeVariables: {
                primaryColor: '#C60C30',
                primaryTextColor: '#000',
                primaryBorderColor: '#00507F',
                lineColor: '#00507F',
                secondaryColor: '#00507F',
                tertiaryColor: '#C0C0C0',
                fontSize: '16px'
            }
        });
        
        Reveal.initialize({
            hash: true,
            center: false,
            transition: 'slide',
            transitionSpeed: 'default',
            controls: true,
            progress: true,
            slideNumber: true,
            keyboard: true,
            overview: true,
            help: true,
            plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
        });

        // Render mermaid diagrams after slide changes
        Reveal.on('slidechanged', () => {
            mermaid.run({
                querySelector: '.mermaid',
            });
        });

        // Initial render
        Reveal.on('ready', () => {
            mermaid.run({
                querySelector: '.mermaid',
            });
        });
    </script>
</body>
</html>