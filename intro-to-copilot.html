<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Copilot: Beyond the Basics</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reveal.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/theme/black.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/plugin/highlight/monokai.css">
    <style>
        /* AA Brand Colors */
        :root {
            --r-main-font-size: 32px;   
            --aa-red: #C60C30;
            --aa-blue: #00507F;
            --aa-silver: #C0C0C0;
            --aa-dark: #1a1a1a;
        }

        .reveal {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }

        .reveal h1, .reveal h2, .reveal h3 {
            color: var(--aa-red);
            text-transform: none;
        }

        .reveal h1 {
            font-size: 2.0em;
            margin-bottom: 0.5em;
        }

        .reveal h2 {
            font-size: 1.7em;
            margin-bottom: 0.5em;
        }

        .reveal .subtitle {
            color: var(--aa-silver);
            font-size: 1.2em;
            font-style: italic;
        }

        .reveal section {
            text-align: left;
        }

        .reveal .title-slide {
            text-align: center;
        }

        .reveal .title-slide h1 {
            margin-top: 1em;
        }

        .reveal a {
            color: var(--aa-blue);
        }

        .reveal a:hover {
            color: var(--aa-red);
        }

        .reveal code {
            background: #2d2d2d;
            padding: 2px 8px;
            border-radius: 3px;
        }

        .reveal pre code {
            background: #2d2d2d;
            padding: 20px;
            border-radius: 5px;
            max-height: 500px;
        }

        .reveal .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2em;
            align-items: start;
        }

        .reveal .highlight-box {
            background: var(--aa-blue);
            padding: 1em;
            border-radius: 5px;
            margin: 1em 0;
        }

        .reveal .accent {
            color: var(--aa-red);
            font-weight: bold;
        }

        .reveal ul {
            margin-left: 0;
        }

        .reveal li {
            margin-bottom: 0.5em;
        }

        .reveal .small {
            font-size: 0.8em;
        }

        .reveal .mermaid {
            background: white;
            padding: 20px;
            border-radius: 10px;
        }

        .reveal blockquote {
            background: var(--aa-blue);
            border-left: 5px solid var(--aa-red);
            padding: 1em;
            margin: 1em 0;
            font-style: italic;
        }

        .reveal .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1em;
        }

        .reveal .comparison-item {
            padding: 1em;
            border-radius: 5px;
        }

        .reveal .good {
            background: rgba(0, 255, 0, 0.1);
            border-left: 5px solid #00ff00;
        }

        .reveal .bad {
            background: rgba(255, 0, 0, 0.1);
            border-left: 5px solid #ff0000;
        }
    </style>
</head>
<body>
    <div class="reveal">
        <div class="slides">
            
            <!-- Title Slide -->
            <section class="title-slide">
                <h1>GitHub Copilot: Beyond the Basics</h1>
                <p class="subtitle">A Comprehensive Guide for Developers</p>
                <p style="margin-top: 2em;">
                    <small>December 12, 2025</small><br>
                    <small><a href="https://developer.aa.com/access/github-copilot">Get Your License</a></small>
                </p>
                <aside class="notes">
                    Welcome everyone! Today we're diving deep into GitHub Copilot's advanced features.
                    This is beyond simple autocomplete - we'll explore autonomous coding, custom agents, and workflows that will transform how you develop.
                    The presentation is about 60 minutes with time for questions.
                </aside>
            </section>

            <!-- Section 1: IDE Integration -->
            <section>
                <section>
                    <h2>Getting Started: IDE Integration</h2>
                    <p>GitHub Copilot has evolved far beyond simple code completion</p>
                    <aside class="notes">
                        Let's start with the foundation - understanding how Copilot integrates with your development environment.
                        This isn't just about autocomplete anymore. Copilot now offers autonomous agents that can read, analyze, and modify entire codebases.
                    </aside>
                </section>

                <section>
                    <h3>Supported IDEs</h3>
                    <ul>
                        <li><span class="accent">Visual Studio Code</span> - Most feature-rich integration</li>
                        <li><span class="accent">Visual Studio</span> - Optimized for .NET developers</li>
                        <li><span class="accent">IntelliJ IDEA</span> - Java/Kotlin-optimized</li>
                        <li><span class="accent">JetBrains Suite & Neovim</span> - Extended support</li>
                    </ul>
                    <div class="highlight-box">
                        <p><strong>Pro Tip:</strong> VS Code offers the complete Copilot experience with full access to all agents and autonomous coding capabilities.</p>
                    </div>
                    <aside class="notes">
                        VS Code is the recommended IDE for the full Copilot experience.
                        If you're doing .NET work, Visual Studio has deep integration.
                        For Java developers, IntelliJ provides intelligent context awareness.
                        The key is that Copilot works where you work - you don't need to change your tools.
                    </aside>
                </section>

                <section>
                    <h3>Understanding Agent Types</h3>
                    <p>Four distinct agents, each designed for specific workflows</p>
                    <div class="two-column">
                        <div>
                            <h4 style="color: var(--aa-blue);">Asking Agents</h4>
                            <ul>
                                <li><strong>Ask Agent</strong> - Q&A expert</li>
                                <li><strong>Plan Agent</strong> - Strategic planner</li>
                            </ul>
                            <p class="small">Provide information without modifying code</p>
                        </div>
                        <div>
                            <h4 style="color: var(--aa-red);">Editing Agents</h4>
                            <ul>
                                <li><strong>Agent</strong> - Autonomous coder</li>
                                <li><strong>Edit Agent</strong> - Focused editor</li>
                            </ul>
                            <p class="small">Actively read workspace and make changes</p>
                        </div>
                    </div>
                    <aside class="notes">
                        This is a crucial distinction. Asking agents give you information and plans but keep you in control of changes.
                        Editing agents can autonomously read your entire codebase and make modifications across multiple files.
                        Agent mode is the most powerful - it's like having a senior developer who can search, analyze, and refactor your entire project.
                    </aside>
                </section>

                <section>
                    <h3>When to Use Each Agent</h3>
                    <div class="mermaid">
graph TD
    Start["Need Help with Code"] --> Question{"What do you need?"}
    Question -->|"Quick answer"| Ask["Use Ask Agent"]
    Question -->|"See plan first"| Plan["Use Plan Agent"]
    Question -->|"Targeted edit"| Edit["Use Edit Agent"]
    Question -->|"Complex multi-file"| Agent["Use Agent Mode"]
    
    Ask --> AskEx["Syntax questions<br/>API examples<br/>Explanations"]
    Plan --> PlanEx["Feature planning<br/>Refactor scope<br/>Architecture"]
    Edit --> EditEx["Focused changes<br/>Single file edits<br/>Quick refactors"]
    Agent --> AgentEx["Multi-file refactoring<br/>Debugging<br/>Complex features"]
                    </div>
                    <aside class="notes">
                        Use this flowchart as your decision guide.
                        Ask agent for quick questions - think of it as Stack Overflow integrated into your IDE.
                        Plan agent when you want to understand what will happen before any code changes.
                        Edit agent for focused changes in specific files.
                        Agent mode for complex tasks that require understanding your entire codebase.
                    </aside>
                </section>

                <section>
                    <h3>Model Selection</h3>
                    <ul>
                        <li><span class="accent">Claude Sonnet 4.x</span> (Recommended)
                            <ul class="small">
                                <li>Excels at complex reasoning</li>
                                <li>Best for multi-step problem solving</li>
                            </ul>
                        </li>
                        <li><span class="accent">Claude Haiku 4.x</span> (For Speed)
                            <ul class="small">
                                <li>Faster responses for quick tasks</li>
                            </ul>
                        </li>
                        <li><span class="accent">GPT-4.1</span> (Alternative)
                            <ul class="small">
                                <li>Sometimes better at creative solutions</li>
                            </ul>
                        </li>
                    </ul>
                    <blockquote>
                        Don't settle for the first result. Different models have different strengths - experiment!
                    </blockquote>
                    <aside class="notes">
                        You can switch models anytime using the model picker.
                        Claude Sonnet is recommended for most tasks - it's particularly strong at understanding legacy code and refactoring.
                        Haiku is faster for simple queries.
                        GPT-4.1 might offer more creative approaches to new implementations.
                        The key: if you're not getting good results, try a different model before giving up.
                    </aside>
                </section>
            </section>

            <!-- Section 2: Practical Examples -->
            <section>
                <section>
                    <h2>Practical Examples & Use Cases</h2>
                    <p>See Copilot in action with real-world scenarios</p>
                    <aside class="notes">
                        Now let's move from theory to practice. These are real examples you can use today.
                        Each example demonstrates specific Copilot capabilities and includes prompts you can adapt.
                    </aside>
                </section>

                <section>
                    <h3>Example 1: Generate Professional README Files</h3>
                    <p><strong>The Scenario:</strong> Your project lacks proper documentation</p>
                    <pre><code class="language-plaintext">Create a comprehensive README.md for this project. Include:
- Project overview and purpose
- Installation instructions
- Usage examples with code snippets
- API documentation
- Contributing guidelines
- License information

Analyze the codebase to understand the tech stack.</code></pre>
                    <p class="small"><strong>Key Insight:</strong> Agents analyze your actual code structure to create accurate, tailored documentation</p>
                    <aside class="notes">
                        This is one of the most valuable uses of Copilot - generating documentation that actually matches your implementation.
                        The agent reads your package.json, source files, and project structure.
                        You're not getting generic templates, you're getting documentation specific to YOUR project.
                        Use Agent mode with #codebase context for best results.
                    </aside>
                </section>

                <section>
                    <h3>Example 2: Project Assessment</h3>
                    <pre><code class="language-plaintext">Analyze this codebase and provide:
1. Architecture overview (patterns, structure)
2. Technology stack and dependencies
3. Code quality assessment
4. Security concerns or vulnerabilities
5. Technical debt areas
6. Recommended improvements prioritized by impact</code></pre>
                    <p><strong>What Copilot identifies:</strong></p>
                    <ul class="small">
                        <li>Outdated dependencies with vulnerabilities</li>
                        <li>Code smells and anti-patterns</li>
                        <li>Missing error handling</li>
                        <li>Performance bottlenecks</li>
                    </ul>
                    <aside class="notes">
                        This is like having a code review from a senior architect on demand.
                        The analysis typically takes a few minutes but provides insights that would take hours of manual review.
                        This is incredibly valuable when inheriting legacy code or planning technical debt paydown.
                        The assessment can inform sprint planning and help prioritize improvements.
                    </aside>
                </section>

                <section>
                    <h3>Example 3: Automated Test Generation</h3>
                    <div class="two-column">
                        <div>
                            <h4>Basic Prompt:</h4>
                            <pre><code class="language-plaintext" style="font-size: 0.5em;">Generate unit tests for UserService:
- Happy path scenarios
- Edge cases
- Error handling
- Mock external dependencies
Use Jest</code></pre>
                        </div>
                        <div>
                            <h4>Advanced Prompt:</h4>
                            <pre><code class="language-plaintext" style="font-size: 0.5em;">Create comprehensive test suite:
1. Unit tests (80%+ coverage)
2. Integration tests for APIs
3. Test data factories
4. Mock setup for database
5. Follow AAA pattern</code></pre>
                        </div>
                    </div>
                    <p class="accent">‚ö†Ô∏è Important: Always review tests to ensure they validate your specific business logic</p>
                    <aside class="notes">
                        Test generation is one of the best ROI activities with Copilot.
                        Writing tests is tedious but critical. Copilot excels at generating test scaffolding and common test cases.
                        The agent understands common patterns but doesn't know your unique business requirements.
                        Always review generated tests, but you'll save hours of boilerplate writing.
                    </aside>
                </section>

                <section>
                    <h3>Example 4: Meta-Prompting</h3>
                    <p>Let Copilot write better prompts for you</p>
                    <pre><code class="language-plaintext">I need to ask Copilot to create a RESTful API 
with authentication. Write a detailed prompt that includes:
- Tech stack (Node.js/Express)
- Auth requirements (JWT with refresh tokens)
- Database schema
- Error handling standards
- API documentation needs</code></pre>
                    <p><strong>Why this works:</strong> Copilot knows what context it needs to generate better code</p>
                    <aside class="notes">
                        This is an advanced technique that experienced users leverage heavily.
                        Copilot knows its own capabilities and limitations better than we do.
                        By asking it to write prompts, you learn what information leads to better results.
                        This helps establish team standards and creates reusable prompt templates.
                    </aside>
                </section>

                <section>
                    <h3>Example 5: Debugging with Context</h3>
                    <pre><code class="language-plaintext" style="font-size: 0.5em;">Analyze this error and suggest fixes:

Error: Cannot read property 'user' of undefined
    at UserController.getProfile (src/controllers/user.js:45)

Context:
- Express API endpoint: GET /api/users/:id/profile
- Uses JWT authentication middleware
- MongoDB database
- Error occurs intermittently (5% of requests)

Provide:
1. Root cause analysis
2. Specific code fix
3. How to prevent similar issues
4. Logging/monitoring improvements</code></pre>
                    <aside class="notes">
                        Debugging is where context really matters. The more information you provide, the better the analysis.
                        Include the full error message, stack trace, what the code is trying to do, when it fails, and any recent changes.
                        Copilot can identify race conditions, missing null checks, auth issues, and async/await problems.
                    </aside>
                </section>

                <section>
                    <h3>Example 6: API Migration</h3>
                    <div class="comparison">
                        <div class="comparison-item bad">
                            <h4>‚ùå Before (Express 4, JS)</h4>
                            <pre><code class="language-javascript" style="font-size: 0.4em;">const express = require('express');
router.get('/users/:id', async (req, res) => {
  try {
    const user = await User.findById(req.params.id);
    res.json(user);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});</code></pre>
                        </div>
                        <div class="comparison-item good">
                            <h4>‚úÖ After (Express 5, TS)</h4>
                            <pre><code class="language-typescript" style="font-size: 0.4em;">import { Router, Request, Response } from 'express';

router.get('/users/:id',
  param('id').isMongoId(),
  async (req: Request, res: Response): Promise&lt;void&gt; => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({ errors: errors.array() });
      return;
    }
    const user = await User.findById(req.params.id);
    if (!user) {
      res.status(404).json({ error: 'User not found' });
      return;
    }
    res.json(user);
  }
);</code></pre>
                        </div>
                    </div>
                    <aside class="notes">
                        Migrations are tedious and error-prone. Copilot excels at these systematic transformations.
                        It can handle framework upgrades, REST to GraphQL conversions, ORM changes.
                        The key is providing clear requirements and examples of the patterns you want.
                        Always test thoroughly, but Copilot saves countless hours on boilerplate conversion.
                    </aside>
                </section>
            </section>

            <!-- Section 3: Building Reusable Assets -->
            <section>
                <section>
                    <h2>Building Reusable Assets</h2>
                    <p>Don't start from scratch every time</p>
                    <aside class="notes">
                        The most efficient Copilot users build libraries of prompts, instructions, and custom agents.
                        These assets encode your team's best practices and common workflows.
                        Think of them as guardrails that keep Copilot aligned with your standards.
                    </aside>
                </section>

                <section>
                    <h3>Custom Assets Architecture</h3>
                    <pre><code class="language-plaintext">your-project/
‚îú‚îÄ‚îÄ .github/
‚îÇ     ‚îú‚îÄ‚îÄ prompts/
‚îÇ     ‚îÇ   ‚îú‚îÄ‚îÄ create-readme.prompt
‚îÇ     ‚îÇ   ‚îú‚îÄ‚îÄ generate-tests.prompt
‚îÇ     ‚îÇ   ‚îî‚îÄ‚îÄ code-review.prompt
‚îÇ     ‚îú‚îÄ‚îÄ instructions/
‚îÇ     ‚îÇ   ‚îú‚îÄ‚îÄ testing.instructions.md
‚îÇ     ‚îÇ   ‚îú‚îÄ‚îÄ api-design.instructions.md
‚îÇ     ‚îÇ   ‚îî‚îÄ‚îÄ security.instructions.md
‚îÇ     ‚îî‚îÄ‚îÄ agents/
‚îÇ         ‚îú‚îÄ‚îÄ docs-agent.md
‚îÇ         ‚îú‚îÄ‚îÄ test-agent.md
‚îÇ         ‚îî‚îÄ‚îÄ security-agent.md
‚îî‚îÄ‚îÄ README.md</code></pre>
                    <aside class="notes">
                        This is the recommended file structure for custom assets.
                        Store them in .github/ so they're version-controlled with your code.
                        Prompts are reusable templates for common tasks.
                        Instructions guide Copilot's behavior for specific domains.
                        Agents are specialized AI assistants with defined roles.
                    </aside>
                </section>

                <section>
                    <h3>Prompts (.prompt files)</h3>
                    <p>Pre-written templates you can invoke quickly</p>
                    <pre><code class="language-markdown">
---
agent: 'agent'
description: 'Create a README.md file for the project'
---

Create a professional README.md following this structure:
- Badge section (build status, coverage, version)
- Project description with clear value proposition
- Quick start (&lt; 5 minutes to first result)
- Detailed installation
- Usage examples with code blocks
- API reference
- Contributing guidelines
- License

Tailor content based on detected language and framework.</code></pre>
                    <p class="small">Save in <code>.github/prompts/create-readme.prompt.md</code></p>
                    <aside class="notes">
                        Prompts eliminate the need to retype common instructions.
                        They ensure consistency across your team.
                        Anyone can invoke these prompts and get standardized output.
                        Build a library for your most frequent tasks: API endpoints, tests, config files, CI/CD pipelines.
                    </aside>
                </section>

                <section>
                    <h3>Instructions (.instructions.md files)</h3>
                    <p>Style guides that Copilot automatically follows</p>
                    <pre><code class="language-yaml" style="font-size: 1em;">---
description: 'API Design Standards'
applyTo: '**/*.java'
---
When creating REST APIs:
- Use plural nouns for resource names (/users, not /user)
- Implement proper HTTP status codes
- Include pagination for list endpoints (page, limit, total)
- Use snake_case for JSON keys
- Always validate input with detailed error messages
- Add OpenAPI/Swagger documentation
- Implement rate limiting headers</code></pre>
                    <p><strong>When to create:</strong> Team-specific standards, security practices, architectural patterns</p>
                    <p class="small">Save in <code>.github/instructions/api-design.instructions.md</code></p>

                    <aside class="notes">
                        Instructions are like living style guides that Copilot follows automatically.
                        Instead of catching violations in code review, the code is generated correctly from the start.
                        They're especially valuable for specialized frameworks, security practices, and naming conventions.
                        New team members inherit these standards immediately through Copilot.
                    </aside>
                </section>

                <section>
                    <h3>Custom Agents (.agent.md files)</h3>
                    <p>Specialized AI assistants for specific workflows</p>
                    <div class="two-column">
                        <div>
                            <h4>Agent Ideas:</h4>
                            <ul class="small">
                                <li>@docs-agent - Documentation writer</li>
                                <li>@test-agent - QA engineer</li>
                                <li>@lint-agent - Style fixer</li>
                                <li>@api-agent - REST endpoint builder</li>
                                <li>@security-agent - Security reviewer</li>
                            </ul>
                        </div>
                        <div>
                            <h4>What Makes a Great Agent:</h4>
                            <ul class="small">
                                <li>Clear role and expertise</li>
                                <li>Specific commands it can use</li>
                                <li>Code examples of preferred style</li>
                                <li>Defined boundaries</li>
                            </ul>
                        </div>
                    </div>
                    <aside class="notes">
                        Custom agents are beyond the four built-in agents.
                        They're specialized assistants with narrow, focused expertise.
                        A test agent only writes tests. A docs agent only writes documentation.
                        This focus produces better results than a general-purpose agent.
                        Start with one agent for your most common task and iterate.
                    </aside>
                </section>

                <section>
                    <h3>Agent Structure Example</h3>
                    <pre><code class="language-markdown" style="font-size: 1em;">---
name: test-agent
description: QA engineer who writes comprehensive tests
---

You are a quality software engineer who writes comprehensive tests.

## Commands
- Run tests: `npm test`
- Coverage: `npm run test:coverage`

## Code style
‚úÖ Good - descriptive names, proper mocking
‚ùå Bad - vague names, no assertions

## Boundaries
- ‚úÖ Always do: Write to `tests/` directory, include edge cases
- ‚ö†Ô∏è Ask first: Before modifying test configuration
- üö´ Never do: Remove failing tests, modify source code</code></pre>
                    <aside class="notes">
                        This shows the structure of an effective agent file.
                        Clear role, specific commands, code examples, and boundaries.
                        The three-tier boundary system is key: always do, ask first, never do.
                        Pro tip: Use Copilot itself to generate agent files - it knows what makes a good agent!
                    </aside>
                </section>

                <section>
                    <h3>Team Benefits of Custom Assets</h3>
                    <ul>
                        <li><span class="accent">Enforce Standards</span> - Without constant vigilance</li>
                        <li><span class="accent">Instant Onboarding</span> - New developers inherit team knowledge immediately</li>
                        <li><span class="accent">Reduce Context Switching</span> - Common tasks become one-click operations</li>
                        <li><span class="accent">Improve Code Review</span> - Less time on style, more on architecture</li>
                    </ul>
                    <div class="highlight-box">
                        <p><strong>Key Principle:</strong> Custom assets only work if they're version-controlled and shared. Treat them like documentation that lives with your code.</p>
                    </div>
                    <aside class="notes">
                        The real value comes from team-wide adoption.
                        Custom assets sitting on one developer's machine don't help anyone.
                        Store them in your repo, version control them, and iterate based on feedback.
                        Start small: 2-3 instruction files and a prompt library for frequent tasks.
                        Build incrementally as you identify patterns worth encoding.
                    </aside>
                </section>
            </section>

            <!-- Section 4: Best Practices & Tips -->
            <section>
                <section>
                    <h2>Best Practices & Tips</h2>
                    <p>Effective patterns for AI-assisted development</p>
                    <aside class="notes">
                        Now let's talk about best practices that separate good Copilot users from great ones.
                        These aren't just tips - they're battle-tested workflows from experienced developers.
                    </aside>
                </section>

                <section>
                    <h3>5 AI-Assisted Coding Techniques</h3>
                    <ol>
                        <li><span class="accent">Let AI Read Your Design Docs First</span>
                            <p class="small">Provide complete context before asking for code</p>
                        </li>
                        <li><span class="accent">Use One AI to Code, Another to Review</span>
                            <p class="small">Generate code, then review it in a fresh session</p>
                        </li>
                        <li><span class="accent">Automate Tests and Validation</span>
                            <p class="small">Let AI generate and maintain test suites</p>
                        </li>
                        <li><span class="accent">AI-Driven Refactoring</span>
                            <p class="small">Modernize legacy code safely and incrementally</p>
                        </li>
                        <li><span class="accent">Work Asynchronously</span>
                            <p class="small">Use multiple chat sessions for parallel tasks</p>
                        </li>
                    </ol>
                    <aside class="notes">
                        These five techniques are the foundation of efficient AI-assisted development.
                        #1 - Don't give isolated prompts. Share design docs and architecture first.
                        #2 - Fresh perspective catches issues the generator missed.
                        #3 - Testing is tedious but critical. Perfect for delegation to AI.
                        #4 - Legacy code modernization without the pain.
                        #5 - Don't wait for responses. Queue up distinct tasks in parallel.
                    </aside>
                </section>

                <section>
                    <h3>Choosing the Right Interaction</h3>
                    <table style="font-size: 0.6em;">
                        <thead>
                            <tr>
                                <th>Task Type</th>
                                <th>Method</th>
                                <th>Why</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Quick syntax question</td>
                                <td>Ask agent</td>
                                <td>Fast, focused answer</td>
                            </tr>
                            <tr>
                                <td>Refactoring multiple files</td>
                                <td>Agent mode</td>
                                <td>Autonomous, reads workspace</td>
                            </tr>
                            <tr>
                                <td>Planning complex feature</td>
                                <td>Plan agent</td>
                                <td>Roadmap before changes</td>
                            </tr>
                            <tr>
                                <td>Focused edit in current file</td>
                                <td>Inline chat (Ctrl+I)</td>
                                <td>Keeps you in flow</td>
                            </tr>
                            <tr>
                                <td>Code while actively typing</td>
                                <td>Inline suggestions</td>
                                <td>Autocomplete on steroids</td>
                            </tr>
                        </tbody>
                    </table>
                    <aside class="notes">
                        Choosing the right interaction method is critical for efficiency.
                        Inline suggestions for active coding - that's your autocomplete.
                        Ask agent for quick questions - like Stack Overflow in your IDE.
                        Agent mode for complex multi-file work - that's your autonomous coder.
                        Plan agent when you want to see what will happen first.
                        Inline chat for quick edits without context switching.
                    </aside>
                </section>

                <section>
                    <h3>Security Considerations</h3>
                    <div class="two-column">
                        <div>
                            <h4 style="color: #ff4444;">‚ùå Never Share:</h4>
                            <ul class="small">
                                <li>API keys or secrets</li>
                                <li>Passwords</li>
                                <li>Connection strings with credentials</li>
                                <li>PII (personally identifiable info)</li>
                                <li>Proprietary business logic</li>
                            </ul>
                        </div>
                        <div>
                            <h4 style="color: #44ff44;">‚úÖ Always Review:</h4>
                            <ul class="small">
                                <li>Authentication/authorization logic</li>
                                <li>Input validation</li>
                                <li>Cryptographic operations</li>
                                <li>Database queries</li>
                                <li>File system operations</li>
                            </ul>
                        </div>
                    </div>
                    <blockquote>
                        Treat Copilot's output like code from a junior developer - it might be excellent, but always needs review.
                    </blockquote>
                    <aside class="notes">
                        Security is non-negotiable. Never include sensitive data in prompts.
                        Your prompts may be used to improve the model, so treat them as potentially public.
                        For security-critical code, use a multi-step approach: generate, review, verify, test, peer review.
                        Copilot is a tool that amplifies your expertise, not a replacement for security judgment.
                    </aside>
                </section>

                <section>
                    <h3>Performance Tips</h3>
                    <div class="two-column">
                        <div>
                            <h4>Faster Iteration:</h4>
                            <ul class="small">
                                <li>Keep prompts concise but complete</li>
                                <li>Build a prompt library</li>
                                <li>Use keyboard shortcuts</li>
                                <li>Use inline chat for quick edits</li>
                            </ul>
                        </div>
                        <div>
                            <h4>Better Results:</h4>
                            <ul class="small">
                                <li>Reference files explicitly</li>
                                <li>Specify frameworks and versions</li>
                                <li>Include error messages when debugging</li>
                                <li>Mention performance requirements upfront</li>
                            </ul>
                        </div>
                    </div>
                    <div class="highlight-box">
                        <p><strong>Context Management:</strong> Use #codebase, #file, #selection to add specific context. Choose the right agent mode for your task.</p>
                    </div>
                    <aside class="notes">
                        These tips come from thousands of hours of Copilot usage.
                        Concise prompts with complete context produce the best results.
                        Build a library so you don't retype common instructions.
                        Learn keyboard shortcuts to stay in flow.
                        Explicit references help Copilot understand exactly what you want to modify.
                    </aside>
                </section>

                <section>
                    <h3>Common Pitfalls to Avoid</h3>
                    <ul>
                        <li><span class="accent">Over-reliance</span> - Don't stop thinking critically</li>
                        <li><span class="accent">Ignoring edge cases</span> - AI generates happy-path code</li>
                        <li><span class="accent">Skipping tests</span> - Fast code generation ‚â† skip testing</li>
                        <li><span class="accent">Copy-paste without understanding</span> - Always understand the code</li>
                        <li><span class="accent">Not updating instructions</span> - Keep custom assets current</li>
                        <li><span class="accent">Exposing sensitive data</span> - Never include secrets in prompts</li>
                    </ul>
                    <aside class="notes">
                        These are the most common mistakes new Copilot users make.
                        Copilot amplifies your expertise but isn't a replacement for engineering judgment.
                        Always think about edge cases, error conditions, and boundary scenarios.
                        Fast code generation makes testing even more important, not less.
                        Always understand code before integrating it.
                        Keep your custom assets updated as your standards evolve.
                    </aside>
                </section>

                <section>
                    <h3>Continuous Feedback-Driven Workflow</h3>
                    <div class="mermaid">
flowchart LR
    A["Design Docs"] --> B["Generate Code"]
    B --> C["Review with<br/>Fresh Perspective"]
    C --> D["Generate/Update<br/>Tests"]
    D --> E["Refactor/<br/>Modernize"]
    E --> F["Iterate/<br/>Improve Prompts"]
    F --> A
    
    style A fill:#00507F,color:#fff
    style B fill:#C60C30,color:#fff
    style C fill:#00507F,color:#fff
    style D fill:#C60C30,color:#fff
    style E fill:#00507F,color:#fff
    style F fill:#C60C30,color:#fff
                    </div>
                    <p class="small">Chain techniques into a continuous workflow for maximum efficiency</p>
                    <aside class="notes">
                        This is how experienced users work. It's not about using one technique - it's about chaining them.
                        Start with design-driven prompting for clear context.
                        Generate code, then review from a fresh perspective.
                        Automate test generation to ensure everything stays verifiable.
                        Use AI for refactoring and modernization in the background.
                        Feed back results to refine your prompts over time.
                        This creates a virtuous cycle where your AI workflows mature into reliable systems.
                    </aside>
                </section>
            </section>

            <!-- Closing Slide -->
            <section>
                <section class="title-slide">
                    <h2>Key Takeaways</h2>
                    <ul style="text-align: left; display: inline-block;">
                        <li>Start small - Begin with documentation and tests</li>
                        <li>Be specific - Detailed prompts produce better results</li>
                        <li>Build assets - Create reusable prompts and instructions</li>
                        <li>Stay secure - Always review code, never expose secrets</li>
                        <li>Choose the right agent for the task</li>
                        <li>Iterate and refine your approach continuously</li>
                    </ul>
                    <aside class="notes">
                        Let's recap the key points.
                        Start small with low-risk, high-value tasks like documentation.
                        Be specific in your prompts - context is everything.
                        Build custom assets to encode your team's standards.
                        Security is non-negotiable - review everything, never share secrets.
                        Choose the right interaction method for each task.
                        This is an iterative process - you'll get better with practice.
                    </aside>
                </section>

                <section class="title-slide">
                    <h2>Remember</h2>
                    <blockquote style="font-size: 1.2em;">
                        Copilot is a tool that amplifies your expertise. The better developer you are, the more value you'll extract from it.
                    </blockquote>
                    <p style="margin-top: 2em;">Use it to eliminate repetitive work so you can focus on creative, high-impact aspects of software engineering.</p>
                    <aside class="notes">
                        This is the most important point: Copilot amplifies expertise, it doesn't replace it.
                        The better you are at software engineering, the more effective you'll be with Copilot.
                        Use it for what computers do well - repetitive tasks, boilerplate, pattern recognition.
                        Save your brain power for what humans do well - creativity, architecture, business logic.
                    </aside>
                </section>

                <section class="title-slide">
                    <h1>Thank You!</h1>
                    <p style="margin-top: 2em;">
                        <strong>Get Your License:</strong><br>
                        <a href="https://developer.aa.com/access/github-copilot">developer.aa.com/access/github-copilot</a>
                    </p>
                    <p style="margin-top: 2em;">
                        <strong>Resources:</strong><br>
                        <a href="https://docs.github.com/copilot">GitHub Copilot Docs</a><br>
                        <a href="https://github.com/github/awesome-copilot">Awesome Copilot Repository</a>
                    </p>
                    <p style="margin-top: 2em; font-size: 0.8em;">Questions?</p>
                    <aside class="notes">
                        Thank you for your time today! I hope you found this valuable.
                        Get your license at the link shown if you haven't already.
                        Check out the Awesome Copilot repository for more prompts and examples.
                        I'm happy to take questions now or connect afterward.
                    </aside>
                </section>
            </section>

        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reveal.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/plugin/notes/notes.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/plugin/highlight/highlight.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/plugin/markdown/markdown.js"></script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#C60C30',
                primaryTextColor: '#000',
                primaryBorderColor: '#00507F',
                lineColor: '#00507F',
                secondaryColor: '#00507F',
                tertiaryColor: '#C0C0C0'
            }
        });
        
        Reveal.initialize({
            hash: true,
            center: false,
            transition: 'slide',
            transitionSpeed: 'default',
            controls: true,
            progress: true,
            slideNumber: true,
            keyboard: true,
            overview: true,
            help: true,
            plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
        });

        // Render mermaid diagrams after slide changes
        Reveal.on('slidechanged', () => {
            mermaid.run({
                querySelector: '.mermaid',
            });
        });

        // Initial render
        Reveal.on('ready', () => {
            mermaid.run({
                querySelector: '.mermaid',
            });
        });
    </script>
</body>
</html>